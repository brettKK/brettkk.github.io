<!DOCTYPE html>
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/styles/default.min.css">
<script src="https://cdn.bootcss.com/highlight.js/9.12.0/languages/yaml.min.js"></script>
<html lang="zh-cn">
  <head>
    <title>python | brettkk</title>

    <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">    
<meta name="viewport" content="width=device-width,minimum-scale=1">
<meta name="description" content="python 历史 🔗 简单易用。 1989 年荷兰人Guido von Rossum开始写 Python">
<meta name="generator" content="Hugo 0.103.1" />


  <META NAME="ROBOTS" CONTENT="NOINDEX, NOFOLLOW">


<link href="https://cdn.bootcss.com/highlight.js/9.15.10/styles/zenburn.min.css" rel="stylesheet">
<script src="https://cdn.bootcss.com/highlight.js/9.15.10/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script>


<link rel="stylesheet" href="http://brettkk.github.io/css/syntax.css" />


<link rel="stylesheet" href="/css/style.css">



<link rel="shortcut icon" href="/images/favicon.ico" type="image/x-icon" />




  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/katex.min.css" integrity="sha384-RZU/ijkSsFbcmivfdRBQDtwuwVqK7GMOw6IMvKyeWL2K5UAlyp6WonmB8m7Jd0Hn" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/katex.min.js" integrity="sha384-pK1WpvzWVBQiP0/GjnvRxV4mOb0oxFuyRxJlk6vVw146n3egcN5C925NCP7a7BY8" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/contrib/auto-render.min.js" integrity="sha384-vZTG03m+2yp6N6BNi5iM4rW4oIwk5DfcNdFfxkk9ZWpDriOkXX8voJBFrAO7MpVl" crossorigin="anonymous"
    onload="renderMathInElement(document.body);"></script>




  </head>

  <body>
    <nav class="navigation">
	
		<a href="/"> <span class="arrow">←</span>Home</a>
	
	<a href="/posts">Archive</a>
	<a href="/tags">Tags</a>
	<a href="/about">About</a>

	

	
</nav>


    <main class="main">
      

<section id="single">
    <h1 class="title">python</h1>

    <div class="tip">
        <time datetime="2024-12-05 11:33:56 &#43;0800 CST">Dec 5, 2024</time>
        <span class="split">
          ·
        </span>
        <span>
          2518 words
        </span>
        <span class="split">
          ·
        </span>
        <span>
          6 minute read
        </span>
    </div>

    
    
        
  
    <aside class="toc">
      <details>
          <summary>Table of Contents
          </summary>
          <div>
              <nav id="TableOfContents">
  <ul>
    <li><a href="#python-历史">python 历史</a></li>
    <li><a href="#python-enhancementt-proposal-8">Python Enhancementt Proposal 8</a></li>
    <li><a href="#python-解释器">python 解释器</a></li>
    <li><a href="#特殊语法">特殊语法</a>
      <ul>
        <li><a href="#函数参数">函数参数</a></li>
        <li><a href="#内部特殊函数">内部特殊函数</a></li>
        <li><a href="#装饰器">装饰器</a></li>
        <li><a href="#可迭代对象迭代器生成器">可迭代对象，迭代器，生成器</a></li>
        <li><a href="#函数的传参方式">函数的传参方式</a></li>
        <li><a href="#变量的作用域">变量的作用域</a></li>
        <li><a href="#python-的一切皆对象">Python 的一切皆对象</a></li>
        <li><a href="#python-的闭包函数">python 的闭包函数</a></li>
        <li><a href="#描述器">描述器</a></li>
        <li><a href="#模块与包">模块与包</a></li>
        <li><a href="#访问可见性">访问可见性</a></li>
        <li><a href="#python-程序退出方式">python 程序退出方式</a></li>
        <li><a href="#gil-global-interpreter-lock">GIL (global interpreter lock)</a></li>
      </ul>
    </li>
    <li><a href="#编译与反编译">编译与反编译</a>
      <ul>
        <li><a href="#code-object">code object</a></li>
        <li><a href="#frame">frame</a></li>
        <li><a href="#静态分析工具">静态分析工具</a></li>
      </ul>
    </li>
    <li><a href="#python-数据结构与算法">python 数据结构与算法</a>
      <ul>
        <li><a href="#collections-集合">collections 集合</a></li>
        <li><a href="#打包功能">打包功能</a></li>
      </ul>
    </li>
    <li><a href="#实验场">实验场</a></li>
  </ul>
</nav>
          </div>
      </details>
    </aside>
  


    


    <div class="content">
      <h1 id="python-历史">python 历史 <a href="#python-%e5%8e%86%e5%8f%b2" class="anchor">🔗</a></h1><p>  简单易用。<br></p>
<p>  1989 年荷兰人<code>Guido von Rossum</code>开始写 Python 语言的解释器。<br>
  1994 年 1 月：Python 1.0 正式发布<br>
  2000 年 10 月 Python 2.0 发布, <br>
  2008 年 12 月 Python 3.0 发布，不完全兼容之前的 Python 代码<br></p>
<p>  代码中<code>import sys</code> <code>sys.version_info, sys.version</code> 模块查询 python 版本信息。</p>
<h1 id="python-enhancementt-proposal-8">Python Enhancementt Proposal 8 <a href="#python-enhancementt-proposal-8" class="anchor">🔗</a></h1><p>  PEP 8 对于 python 代码格式的指南。 pylint python 的源码静态分析工具， 检查代码是否符合 PEP 8 的规范。</p>
<h1 id="python-解释器">python 解释器 <a href="#python-%e8%a7%a3%e9%87%8a%e5%99%a8" class="anchor">🔗</a></h1><p>   <a href="https://zh.wikipedia.org/zh-cn/Python" target="_blank" rel="noopener">python</a>, cpython 解释器 (最常见的实现方式)。</p>
<hr>
<h1 id="特殊语法">特殊语法 <a href="#%e7%89%b9%e6%ae%8a%e8%af%ad%e6%b3%95" class="anchor">🔗</a></h1><h2 id="函数参数">函数参数 <a href="#%e5%87%bd%e6%95%b0%e5%8f%82%e6%95%b0" class="anchor">🔗</a></h2><p>函数参数<code>*arg</code>代表可变参数，类型为元组。</p>
<p><code>**kwargs</code>代表关键字参数，可以接收用参数名=参数值的方式传入的参数，传入的参数的会打包成一个字典。</p>
<p>默认参数的值是函数定义时计算的，可能会导致某些陷阱，尤其是在可变对象（如列表或字典）作为默认值时。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">append_item</span>(item, item_list<span style="color:#f92672">=</span>[]):  <span style="color:#75715e"># 默认列表是可变的</span>
</span></span><span style="display:flex;"><span>    item_list<span style="color:#f92672">.</span>append(item)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> item_list
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>print(append_item(<span style="color:#ae81ff">1</span>))  <span style="color:#75715e"># [1]</span>
</span></span><span style="display:flex;"><span>print(append_item(<span style="color:#ae81ff">2</span>))  <span style="color:#75715e"># [1, 2]，问题：第二次调用时默认值已经被修改</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">append_item</span>(item, item_list<span style="color:#f92672">=</span><span style="color:#66d9ef">None</span>):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> item_list <span style="color:#f92672">is</span> <span style="color:#66d9ef">None</span>:
</span></span><span style="display:flex;"><span>        item_list <span style="color:#f92672">=</span> []
</span></span><span style="display:flex;"><span>    item_list<span style="color:#f92672">.</span>append(item)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> item_list
</span></span></code></pre></div><h2 id="内部特殊函数">内部特殊函数 <a href="#%e5%86%85%e9%83%a8%e7%89%b9%e6%ae%8a%e5%87%bd%e6%95%b0" class="anchor">🔗</a></h2><p>  名称前后都有双下划线， 例如：<code>__new__</code>方法在创建对象时被调用，比<code>__init__</code>更早执行，主要用于控制实例的创建过程。<code>__init__</code>用于初始化对象，在创建对象时被自动调用。</p>
<h2 id="装饰器">装饰器 <a href="#%e8%a3%85%e9%a5%b0%e5%99%a8" class="anchor">🔗</a></h2><p>  <code>装饰器</code>：添加一些扩展行为，来实现装饰的目的；装饰器函数在加载模块时执行，被装饰的函数在明确调用时执行。<br>
   装饰器的功能上与 java spring 里的 aop， rust 里的过程宏达到相同的目的。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#75715e"># 装饰器函数</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">simple_decorator</span>(func):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">wrapper</span>():
</span></span><span style="display:flex;"><span>        print(<span style="color:#e6db74">&#34;Before function call&#34;</span>)
</span></span><span style="display:flex;"><span>        func()
</span></span><span style="display:flex;"><span>        print(<span style="color:#e6db74">&#34;After function call&#34;</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> wrapper
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 使用装饰器</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">@simple_decorator</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">say_hello</span>():
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">&#34;Hello, world!&#34;</span>)
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 等价于 say_hello = simple_decorator(say_hello)</span>
</span></span><span style="display:flex;"><span>say_hello()
</span></span></code></pre></div><h2 id="可迭代对象迭代器生成器">可迭代对象，迭代器，生成器 <a href="#%e5%8f%af%e8%bf%ad%e4%bb%a3%e5%af%b9%e8%b1%a1%e8%bf%ad%e4%bb%a3%e5%99%a8%e7%94%9f%e6%88%90%e5%99%a8" class="anchor">🔗</a></h2><p>  三者的关系：可迭代对象 &gt; 迭代器 &gt; 生成器。<br>
  可迭代对象 iterable: 是一个容器，实现<code>__iter__</code>方法返回一个 iterator 迭代器。<br>
  迭代器使用 next 函数， iterator： 有状态。 实现<code>__next__()</code> 和<code>__iter__()</code>方法的对象。实现了<code>__next__</code> 方法的对象都可以称为迭代器。<br>
  生成器 generator， 特殊的迭代器。 生成器函数（带 yield）和生成器表达式 （与列表推导式类似， 使用小括号包裹）。<br></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>lst <span style="color:#f92672">=</span> [<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">5</span>]
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span>  lst:
</span></span><span style="display:flex;"><span>  print(i)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>lst <span style="color:#f92672">=</span> [<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">5</span>]
</span></span><span style="display:flex;"><span>it <span style="color:#f92672">=</span> iter(lst) <span style="color:#75715e"># 调用可迭代对象的iter方法返回迭代器。</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> it:
</span></span><span style="display:flex;"><span>  print(i)
</span></span></code></pre></div><h2 id="函数的传参方式">函数的传参方式 <a href="#%e5%87%bd%e6%95%b0%e7%9a%84%e4%bc%a0%e5%8f%82%e6%96%b9%e5%bc%8f" class="anchor">🔗</a></h2><p>在 Python 中，函数参数传递的机制被称为“传对象引用”（pass-by-object-reference）。</p>
<h2 id="变量的作用域">变量的作用域 <a href="#%e5%8f%98%e9%87%8f%e7%9a%84%e4%bd%9c%e7%94%a8%e5%9f%9f" class="anchor">🔗</a></h2><p>Python 中的作用域遵循 LEGB（Local → Enclosing → Global → Built-in）规则，即：</p>
<ul>
<li>Local（局部作用域）：函数内部定义的变量，函数外部无法访问。</li>
<li>Enclosing（封闭作用域）：嵌套函数的外部函数中的变量， 常出现在闭包函数中访问外部函数中的变量。</li>
<li>Global（全局作用域）：模块级别定义的变量，函数外部可以访问。</li>
<li>Built-in（内置作用域）：Python 内置的函数和变量，比如 print()、int() 等</li>
</ul>
<h2 id="python-的一切皆对象">Python 的一切皆对象 <a href="#python-%e7%9a%84%e4%b8%80%e5%88%87%e7%9a%86%e5%af%b9%e8%b1%a1" class="anchor">🔗</a></h2><p>函数也是对象，包含了需要执行的代码和其他属性（例如支持闭包获取外部变量的 closure 属性）。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">greet</span>():
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;&#34;&#34;This function greets.&#34;&#34;&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;Hello, world!&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>print(greet<span style="color:#f92672">.</span>__name__)  <span style="color:#75715e"># 输出 &#34;greet&#34;</span>
</span></span><span style="display:flex;"><span>print(greet<span style="color:#f92672">.</span>__doc__)   <span style="color:#75715e"># 输出 &#34;This function greets.&#34;</span>
</span></span><span style="display:flex;"><span>print(greet<span style="color:#f92672">.</span>__code__)  <span style="color:#75715e"># 存储代码等信息</span>
</span></span></code></pre></div><h2 id="python-的闭包函数">python 的闭包函数 <a href="#python-%e7%9a%84%e9%97%ad%e5%8c%85%e5%87%bd%e6%95%b0" class="anchor">🔗</a></h2><p>闭包函数： 保存了对外部函数的自由变量的引用。这些自由变量的引用会保存在 闭包的环境 中（通常保存在 <code>__closure__</code> 属性中）
当你创建一个闭包时，Python 会：
创建一个新的函数对象。
创建一个 cell 对象来持有外部函数的变量的引用。
将这些 cell 对象赋值给该函数的 <strong>closure</strong> 属性。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">outer</span>(x):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">inner</span>(y):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> x <span style="color:#f92672">+</span> y  <span style="color:#75715e"># inner 函数引用了 outer 的变量 x</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> inner  <span style="color:#75715e"># 返回 inner 函数</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>closure <span style="color:#f92672">=</span> outer(<span style="color:#ae81ff">10</span>)  <span style="color:#75715e"># 创建闭包</span>
</span></span><span style="display:flex;"><span>print(closure(<span style="color:#ae81ff">5</span>))  <span style="color:#75715e"># 输出 15</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>print(closure<span style="color:#f92672">.</span>__closure__)  <span style="color:#75715e"># 显示闭包的环境</span>
</span></span><span style="display:flex;"><span>print(closure<span style="color:#f92672">.</span>__closure__[<span style="color:#ae81ff">0</span>]<span style="color:#f92672">.</span>cell_contents)  <span style="color:#75715e"># 输出 10</span>
</span></span></code></pre></div><h2 id="描述器">描述器 <a href="#%e6%8f%8f%e8%bf%b0%e5%99%a8" class="anchor">🔗</a></h2><p>通过描述器控制类属性的设置和访问。当访问对象的属性时，遵循以下优先级： 属性是描述器，调用描述器的<code>__get__()</code>方法返回属性；没有描述器时，访问实例的字典。</p>
<p>描述器： class 中定义了<code>__get__</code> <code>__set__</code> <code>__delete__</code>方法。<br>
<code>dis.dis(&quot;a.b&quot;)</code>编程成<code>LOAD_ATTR</code>字节码。</p>
<h2 id="模块与包">模块与包 <a href="#%e6%a8%a1%e5%9d%97%e4%b8%8e%e5%8c%85" class="anchor">🔗</a></h2><p>  文件夹就是一个包，要有一个名为<code>__init__.py</code>的文件。每个 Python 文件是一个模块。<code>import</code>导入包，<code>from x import y</code>导入模块<br></p>
<p>  导入的模块除了定义函数之外还有可以执行代码，那么 Python 解释器在导入这个模块时就会执行这些代码。<br>
  <code>if __name__ == '__main__':</code> , <code>__name__</code>是 Python 中一个隐含的变量它代表了模块的名字, 只有被 Python 解释器直接执行的模块的名字才是<code>__main__</code>。</p>
<h2 id="访问可见性">访问可见性 <a href="#%e8%ae%bf%e9%97%ae%e5%8f%af%e8%a7%81%e6%80%a7" class="anchor">🔗</a></h2><p>  在给属性命名时可以用两个下划线作为开头, 属性是私有的。<br>
  Python 并没有从语法上严格保证私有属性或方法的私密性，它只是给私有的属性和方法换了一个名字来妨碍对它们的访问，事实上如果你知道更换名字的规则仍然可以访问到它们。<br></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>  <span style="color:#ae81ff">16</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Test</span>:
</span></span><span style="display:flex;"><span>   <span style="color:#ae81ff">15</span>     <span style="color:#66d9ef">def</span> __init__(self, foo):
</span></span><span style="display:flex;"><span>   <span style="color:#ae81ff">14</span>         self<span style="color:#f92672">.</span>__foo <span style="color:#f92672">=</span> foo
</span></span><span style="display:flex;"><span>   <span style="color:#ae81ff">13</span>
</span></span><span style="display:flex;"><span>   <span style="color:#ae81ff">12</span>     <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">__bar</span>(self):
</span></span><span style="display:flex;"><span>   <span style="color:#ae81ff">11</span>         print(self<span style="color:#f92672">.</span>__foo)
</span></span><span style="display:flex;"><span>   <span style="color:#ae81ff">10</span>         print(<span style="color:#e6db74">&#39;__bar&#39;</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#ae81ff">9</span>
</span></span><span style="display:flex;"><span>    <span style="color:#ae81ff">8</span>
</span></span><span style="display:flex;"><span>    <span style="color:#ae81ff">7</span> <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">main</span>():
</span></span><span style="display:flex;"><span>    <span style="color:#ae81ff">6</span>     test <span style="color:#f92672">=</span> Test(<span style="color:#e6db74">&#39;hello&#39;</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#ae81ff">5</span>     test<span style="color:#f92672">.</span>_Test__bar()
</span></span><span style="display:flex;"><span>    <span style="color:#ae81ff">4</span>     print(test<span style="color:#f92672">.</span>_Test__foo)
</span></span><span style="display:flex;"><span>    <span style="color:#ae81ff">3</span>
</span></span><span style="display:flex;"><span>    <span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span>    <span style="color:#ae81ff">1</span> <span style="color:#66d9ef">if</span> __name__ <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;__main__&#34;</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#ae81ff">17</span>      main()
</span></span></code></pre></div><p>  属性命名以单下划线开头，通过这种方式来暗示属性是受保护的，不建议外界直接访问， 但可以直接访问到。<br></p>
<h2 id="python-程序退出方式">python 程序退出方式 <a href="#python-%e7%a8%8b%e5%ba%8f%e9%80%80%e5%87%ba%e6%96%b9%e5%bc%8f" class="anchor">🔗</a></h2><ul>
<li>quit(), exit(),</li>
<li>sys.exit() 推荐使用。</li>
<li>os._exit()</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">try</span>:
</span></span><span style="display:flex;"><span>  quit()
</span></span><span style="display:flex;"><span>  exit()
</span></span><span style="display:flex;"><span>  sys<span style="color:#f92672">.</span>exit()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">except</span> <span style="color:#a6e22e">SystemExit</span>:
</span></span><span style="display:flex;"><span>  print(<span style="color:#e6db74">&#34;Ignore Exit&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">&#34;yes&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># try:</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#   os._exit(0) # 直接退出。</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># except:</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#   pass</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># print(&#34;no&#34;)</span>
</span></span></code></pre></div><h2 id="gil-global-interpreter-lock">GIL (global interpreter lock) <a href="#gil-global-interpreter-lock" class="anchor">🔗</a></h2><p>  全局线程锁简单，可靠。<br>
  缺点：python 的计算密集型多线程没法利用 cpu 的多核。<br>
  起多进程的方式利用 cpu 的多核 or 使用没有 GIL 的 python 解释器（Jython, IronPython, PyPy 是有 GIL 的）。</p>
<h1 id="编译与反编译">编译与反编译 <a href="#%e7%bc%96%e8%af%91%e4%b8%8e%e5%8f%8d%e7%bc%96%e8%af%91" class="anchor">🔗</a></h1><p>  编译为字节码 <code>python3 -m example.pyc example.py</code>。反编译模块<code>dis</code>显示可读的字节码。具体字节码是如何执行的，需要到 <code>cpython</code> 的 <code>ceval.c</code>文件的 <code>_PyEval_EvalFrameDefault()</code>。</p>
<h2 id="code-object">code object <a href="#code-object" class="anchor">🔗</a></h2><p>  一种内存中表示 Python 字节码的对象， 在 python 的执行机制中最重要。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">f</span>(a, b<span style="color:#f92672">=</span><span style="color:#ae81ff">3</span>, <span style="color:#f92672">*</span>args, <span style="color:#f92672">**</span>kwargs):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">pass</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 函数被编译为code object</span>
</span></span><span style="display:flex;"><span>code <span style="color:#f92672">=</span> f<span style="color:#f92672">.</span>__code__
</span></span><span style="display:flex;"><span>print(code<span style="color:#f92672">.</span>co_code)
</span></span><span style="display:flex;"><span><span style="color:#75715e"># number of arguments (排除掉*， ** args)</span>
</span></span><span style="display:flex;"><span>print(code<span style="color:#f92672">.</span>co_argcount)
</span></span><span style="display:flex;"><span><span style="color:#75715e">#  number of positional only arguments</span>
</span></span><span style="display:flex;"><span>print(code<span style="color:#f92672">.</span>co_posonlyargcount)
</span></span><span style="display:flex;"><span><span style="color:#75715e">#  number of keyword only arguments</span>
</span></span><span style="display:flex;"><span>print(code<span style="color:#f92672">.</span>co_kwonlyargcount)
</span></span></code></pre></div><h2 id="frame">frame <a href="#frame" class="anchor">🔗</a></h2><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">import</span> inspect
</span></span><span style="display:flex;"><span>frame <span style="color:#f92672">=</span> inspect<span style="color:#f92672">.</span>currentframe()
</span></span></code></pre></div><h2 id="静态分析工具">静态分析工具 <a href="#%e9%9d%99%e6%80%81%e5%88%86%e6%9e%90%e5%b7%a5%e5%85%b7" class="anchor">🔗</a></h2><p>静态代码分析主要用到的是 Pylint 和 Flake8<br>
Flake8 封装了 Pyflakes（检查代码逻辑错误）、McCabe（检查代码复杂性）和 Pycodestyle（检查代码是否符合 PEP-8 规范）工具</p>
<h1 id="python-数据结构与算法">python 数据结构与算法 <a href="#python-%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e4%b8%8e%e7%ae%97%e6%b3%95" class="anchor">🔗</a></h1><p>测试库: unittest 库。test_开头的文件。</p>
<h2 id="collections-集合">collections 集合 <a href="#collections-%e9%9b%86%e5%90%88" class="anchor">🔗</a></h2><p>双端队列，保存最后 N 个元素: <code>collections.deque</code></p>
<p>堆， 找到最大，最小的 N 个元素: <code>heapq</code>模块， 优先队列。</p>
<p>字典中一键多值: <code>collections.defaultdict</code></p>
<p>字典中保存有序: <code>collections.OrderedDict</code></p>
<p>模型文件: Yolo V5, pt 文件， onnx， netron 格式。</p>
<hr>
<h2 id="打包功能">打包功能 <a href="#%e6%89%93%e5%8c%85%e5%8a%9f%e8%83%bd" class="anchor">🔗</a></h2><p><code>setuptools</code>
<code>setup.py</code></p>
<p>python setup.py build, python setup.py install 安装软件。
例如 opencve</p>
<p><code>MANIFEST.in</code>的文件，来控制文件的分发.</p>
<p><code>pip install /path/to/directory</code> pip 将会查找目录中的 setup.py 文件并根据其中的配置进行安装</p>
<h1 id="实验场">实验场 <a href="#%e5%ae%9e%e9%aa%8c%e5%9c%ba" class="anchor">🔗</a></h1><p><a href="https://github.com/makeyourownneuralnetwork" target="_blank" rel="noopener">https://github.com/makeyourownneuralnetwork</a>
Colab 服务： colab.research.google.com</p>

    </div>

    
        <div class="tags">
            
                <a href="http://brettkk.github.io/tags/python">python</a>
            
        </div>
    
    
    

</section>


    </main>
    
    <footer id="footer">
    

    <script src="https://utteranc.es/client.js"
repo="brettKK/brettkk.github.io"
issue-term="title"
theme="github-light"
crossorigin="anonymous"
async>
</script>  

    <div class="copyright">
    
       © Copyright 
       2025 
       <span class="split">
        <svg fill="#bbbbbb" width="15" height="15" version="1.1" id="heart-15" xmlns="http://www.w3.org/2000/svg" width="15px" height="15px" viewBox="0 0 15 15">
  <path d="M13.91,6.75c-1.17,2.25-4.3,5.31-6.07,6.94c-0.1903,0.1718-0.4797,0.1718-0.67,0C5.39,12.06,2.26,9,1.09,6.75&#xA;&#x9;C-1.48,1.8,5-1.5,7.5,3.45C10-1.5,16.48,1.8,13.91,6.75z"/>
</svg>
       </span>
       
    
    </div>

    
      <div class="powerby">
        Powered by <a href='http://www.gohugo.io/'>Hugo</a> Theme By <a href='https://github.com/nodejh/hugo-theme-cactus-plus'>nodejh</a>
      </div>
    
</footer>




  </body>
</html>
